---
title: "Lab 9"
format: gfm
editor: visual
---

```{r}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r}
library(tidyverse)
```

## **Exercise 1. DNA or RNA?**

#### **1.1 Write a function, `dna_or_rna(sequence)`, that determines if a sequence of base pairs is DNA, RNA, or if it is not possible to tell given the sequence provided.**

-   Since all the function will know about the material is the sequence, the only way to tell the difference between DNA and RNA is that RNA has the base Uracil (`"u"`) instead of the base Thymine (`"t"`).

-   Have the function return one of three outputs: “DNA”, “RNA”, or “unknown”. Then run the following three lines of code:

`dna_or_rna("attggc")`

`dna_or_rna("gccaau")`

`dna_or_rna("ccagac")`

`dna_or_rna("tgcacug")`

```{r}
dna_or_rna <- function(sequence){
  bases <- str_split(sequence, pattern = "") |> 
    unlist() |> 
    unique()
  if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
  {return("DNA")}
  else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
  {return("RNA")}
  else {return("unknown")}
}

dna_or_rna("attggc")
```

```{r}
dna_or_rna <- function(sequence){
bases <- str_split(sequence, pattern = "") |> 
  unlist() |> 
  unique()
  if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
  {return("DNA")}
  else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
  {return("RNA")}
  else {return("unknown")}
}

dna_or_rna("gccaau")
```

```{r}
dna_or_rna <- function(sequence){
bases <- str_split(sequence, pattern = "") |> 
  unlist() |> 
  unique()
  if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
  {return("DNA")}
  else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
  {return("RNA")}
  else {return("unknown")}
}

dna_or_rna("ccagac")
```

```{r}
dna_or_rna <- function(sequence){
bases <- str_split(sequence, pattern = "") |> 
  unlist() |> 
  unique()
  if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
  {return("DNA")}
  else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
  {return("RNA")}
  else {return("unknown")}
}

dna_or_rna("tgcacug")
```

#### **1.2 Use the `dna_or_rna()` function and a for loop to print the type of the sequences in the following list.**

```{r}
sequences = c("ttgaatgccttacaactgatcattacacaggcggcatgaagcaaaaatatactgtgaaccaatgcaggcg", 
              "gauuauuccccacaaagggagugggauuaggagcugcaucauuuacaagagcagaauguuucaaaugcau", 
              "gaaagcaagaaaaggcaggcgaggaagggaagaagggggggaaacc", 
              "guuuccuacaguauuugaugagaaugagaguuuacuccuggaagauaauauuagaauguuuacaacugcaccugaucagguggauaaggaagaugaagacu", 
              "gataaggaagaugaagacutucaggaaucuaauaaaaugcacuccaugaauggauucauguaugggaaucagccggguc")

sequence_type <- vector("double", length(sequences))

for (i in seq_along(sequences)){
  sequence_type[i] <- dna_or_rna(sequences[i])
}

sequence_type
```

#### **1.3 Use the `dna_or_rna()` function and an appropriate map function to print the type of the sequences in the above list.**

```{r}
map(sequences, dna_or_rna) |> 
  unlist()
```

#### **1.4 Make your function work with both upper and lower case letters, or even strings with mixed capitalization. Test your function with the following three lines of code:**

`dna_or_rna("ATTGGC")`

`dna_or_rna("gCCAAu")`

`dna_or_rna("ggcacgG")`

```{r}
dna_or_rna <- function(sequence){
   bases <- str_split(sequence, pattern = "") |> 
     unlist() |> 
     tolower() |> 
     unique()
   if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
     {return("DNA")}
   else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
     {return("RNA")}
   else 
     {return("unknown")}
}

dna_or_rna("ATTGGC")
```

```{r}
dna_or_rna <- function(sequence){
   bases <- str_split(sequence, pattern = "") |> 
     unlist() |> 
     tolower() |> 
     unique()
   if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
     {return("DNA")}
   else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
     {return("RNA")}
   else 
     {return("unknown")}
}

dna_or_rna("gCCAAu")
```

```{r}
dna_or_rna <- function(sequence){
   bases <- str_split(sequence, pattern = "") |> 
     unlist() |> 
     tolower() |> 
     unique()
   if (all(bases %in% c("a", "t", "g", "c")) & "t" %in% bases)
     {return("DNA")}
   else if (all(bases %in% c("a", "u", "g", "c")) & "u" %in% bases)
     {return("RNA")}
   else 
     {return("unknown")}
}

dna_or_rna("ggcacgG")
```

## **Exercise 2: Rounding**

Rounding appears to be a very simple arithmetic operation. However, **things get a little bit complicated when it comes to the number 5**, which is at the exact mid-point between rounding up and rounding down.

The `round` function in base R is weird. It is supposed to use a **round half to even rule** when rounding off a **5** (see [https://en.wikipedia.org/wiki/Rounding#Round_half_to_even](#0)). However, this is dependent on your computer’s operating system, and therefore this rule is sometimes inconsistent.

```{r}
round(1.5, digits = 0)
```

#### **2.1 To correct this inconsistency issue, write a custom function that consistently applies a round half away from zero rule.**

-   Under this rule, when rounding off a **5** , your function should round up when it’s positive, and down when it is negative

-   Your function should takes a “digits” argument exactly as in the original R function.

**Hint:** you may need the arithmetic operator `%/%` and the `sign()` function.

```{r}
round_away <- function(x, digits = 0){
  
  x_new<-abs(x * 10 ^ digits)
  x_sign <- sign(x)
  integer <- x_new %/% 1
  decimal <- x_new-integer
  if(decimal < 0.5)
    {x_new <- integer}
  else {x_new <- integer + 1}
  x_rounded <- x_new / 10 ^ digits * x_sign

  return(x_rounded)
}
```

```{r}
round_away(-2.45, digits = 0) 
```

```{r}
round_away(2.45, digits = 1)
```

#### **2.2 Now, building on the previous question, write a custom function that consistently applies a round half to even rule when rounding off a 5.**

**Hint:** you will need the arithmetic operator `%%`.

```{r}
round_even <- function(x, digits = 0){
  
  x_new <- abs(x * 10 ^ digits)
  x_sign <- sign(x)
  integer <- x_new %/% 1
  decimal <- x_new-integer
  if(decimal < 0.5)
    {x_new <- integer}
  else if (decimal == 0.5){
  if(integer %% 2 == 0)
    {x_new <- integer}
    else {x_new <- integer + 1}
  } 
  else {x_new <- integer + 1}
  x_rounded <- x_new / 10 ^ digits * x_sign
 return(x_rounded)

}
```

```{r}
round_even(-2.45, digits = 1) 
```

```{r}
round_even(-2.45, digits = 0)
```
